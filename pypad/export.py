
# THIS FILE IS PART OF PyPad, AND IS GOVERENED BY A PERMISSIBILITY LICENSE 
# GOVERNING ITS USE AND DISTRIBUTION. YOU SHOULD HAVE RECIEVED A COPY OF THIS
# LICENSE WITH THE SOFTWARE; IF NOT PROVIDED, WRITE TO <tjlane@stanford.edu>.
#
# AUTHORS:
# TJ Lane <tjlane@stanford.edu>
# Jonas Sellberg <sellberg@slac.stanford.edu>
#
# Apr 30, 2013

"""
export.py

Library for exporting autogeom geometries to other software packages.
"""

import numpy as np
import h5py

    
def to_cheetah(geometry, filename="pixelmap-cheetah-raw.h5"):
    """
    Convert a CSPad or Metrology object to a Cheetah h5 pixel map.
    
    Writes: 'pixelmap-cheetah-raw.h5'
    
    Parameters
    ----------
    geometry : cspad.CSPad
        The detector geometry to write to disk
	filename : string
		The file name for the output pixel map
    """
    
    print "Exporting to Cheetah format..."
    
    coordinates = ['x', 'y', 'z']
    
    pp = geometry.pixel_positions
    assert pp.shape == (3, 4, 16, 185, 194)
    
    # write an h5
    f = h5py.File(filename, 'w')
    
    # iterate over x/y/z
    for xyz in range(len(coordinates)):
        
        cheetah_image = np.zeros((1480, 1552), dtype=np.float32)
        
        # iterate over each 2x1/quad (note switch)
        
        # new
        for q in range(4):
            for twoXone in range(8):
                
                x_start = 388 * q
                x_stop  = 388 * (q+1)
                
                y_start = 185 * twoXone
                y_stop  = 185 * (twoXone + 1)
                
                # convert mm --> m
                cheetah_image[y_start:y_stop,x_start:x_stop] = np.hstack(( pp[xyz,q,twoXone*2,:,:],
                                                                           pp[xyz,q,twoXone*2+1,:,:] )) / 1000.0
        
        
        f['/%s' % coordinates[xyz]] = cheetah_image
    
    print "Wrote: %s" % (filename)
    f.close()
    
    return

    
def to_odin(geometry, energy, distance_offset, filename):
    """
    Generate an ODIN detector object and write it to disk.
    
    Parameters
    ----------
    geometry : cspad.CSPad
        The detector geometry to write to disk
        
    energy : float
        The energy of the beam, in eV.
        
    distance_offset : float
        A distance offset (along the z-direction), in mm. This can be measured
        directly using a pypad.autogeom.score.PowderReference instance.
        
    filname : str
        The name of file to write. Will end in '.dtc'
    """
    
    try:
        from odin import xray
    except ImportError as e:
        print e
        raise ImportError('Cannot find Odin. You must have Odin installed to '
                          'export to Odin. Download and install Odin from '
                          'https://github.com/tjlane/odin')
        
    # we have to generate an odin-type basis grid -- maintains code separation
    pypad_bg = geometry.basis_repr
    odin_bg  = xray.BasisGrid()
    for i in range(pypad_bg.num_grids):
        p, s, f, shp = pypad_bg.get_grid(i)
        p[2] += distance_offset # translate to make the origin the interaction site
        odin_bg.add_grid(p, s, f, shp)
    
        
    # recall that pypad assumes the beam is along the z-direction (CXI conven.)
    energy /= 1000.0 # convert to keV : pypad is eV, Odin is keV
    b = xray.Beam(1e11, energy=energy) # 1e11 photons per shot
    d = xray.Detector(odin_bg, b)
    d.save(filename)
    
    return
    
    
def to_text(geometry, filename):
    """
    Write a CSPAD geometry to disk in the following format:
    
        p_x p_y p_z     s_x s_y s_z     f_x f_y f_z
        ...
        
    and include some comments.    
    
    
    Parameters
    ----------
    geometry : cspad.CSPad
        The detector geometry to write to disk
        
    filname : str
        The name of file to write. Will end in '.dtc'
    """
    
    # generate a preamble
    preamble = """
# This file contains a CSPAD geometry generated by PyPad: 
# http://www.github.com/tjlane/pypad
#
# The following is a basis grid representation with the following vectors
#
#   p : position vector for an ASIC
#   s : slow-scan pixel vector
#   f : fast-scan pixel vector
#
# all units are mm. Each ASIC is 185 x 194 pixels.
# See the PyPad documentation for more information.


#            p_x        p_y        p_z           s_x        s_y        s_z           f_x        f_y        f_z
"""

    # loop over each grid element and add it to the file
    bg = geometry.basis_repr
    body = ""
    
    
    def format(s, total_len=10):
        """
        A little formatting function
        """
        sf = '%.5f' % s
        pad = total_len - len(sf)
        if pad > 0:
            sf = ' ' * pad + sf
        return sf
        
    
    for i in range(bg.num_grids):
        
        # if we're starting a new quad, note that in the file
        if i % 16 == 0:
            body += ('\n# QUAD %d\n' % (i/16))
        
        # add the basis grid
        p, s, f, shp = bg.get_grid(i)
        strp = ' '.join( [ format(x) for x in p ] )
        strs = ' '.join( [ format(x) for x in s ] )
        strf = ' '.join( [ format(x) for x in f ] )
        
        tb = ' ' * 4
        asic = str(i)
        if len(asic) == 1:
            asic = ' ' + asic
        
        body += (asic + tb + strp + tb + strs + tb + strf + '\n')
        
    f = open(filename, 'w')
    f.write(preamble + body)
    f.close()
    
    print "Wrote CSPAD to text at: %s" % filename
    
    return

